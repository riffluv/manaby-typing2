import { useState, useEffect, useCallback, useRef } from 'react';
import * as wanakana from 'wanakana';
import { wordList } from '@/data/wordList';
import styles from '@/styles/TypingGame.module.css';
import { convertHiraganaToRomaji, getAllRomajiPatterns, createTypingChars, TypingChar } from '@/utils/japaneseUtils';
import MCPStatus from '@/components/MCPStatus';
import type { GameScoreLog, PerWordScoreLog } from '@/types/score';
import { calcScoreWithWorker } from '@/components/TypingGame.tsx.new';

// --- Web Workerスコア計算ラッパー ---
import type { ScoreWorkerRequest, ScoreWorkerResponse } from '@/workers/scoreWorker';

let scoreWorker: Worker | null = null;
function getScoreWorker() {
  if (!scoreWorker) {
    scoreWorker = new Worker(new URL('@/workers/scoreWorker.ts', import.meta.url));
  }
  return scoreWorker;
}

export function calcScoreWithWorker(payload: any): Promise<any> {
  return new Promise((resolve) => {
    const worker = getScoreWorker();
    const handleMessage = (e: MessageEvent<ScoreWorkerResponse>) => {
      if (e.data.type === 'scoreResult') {
        resolve(e.data.payload);
        worker.removeEventListener('message', handleMessage);
      }
    };
    worker.addEventListener('message', handleMessage);
    const req: ScoreWorkerRequest = { type: 'calcScore', payload };
    worker.postMessage(req);
  });
}

const TypingGame: React.FC<{ onGoMenu?: () => void; onGoRanking?: () => void }> = ({ onGoMenu, onGoRanking }) => {
  // 現在のお題のインデックス
  const [currentWordIndex, setCurrentWordIndex] = useState(0);
  
  // 現在のお題
  const [currentWord, setCurrentWord] = useState({ 
    japanese: '', 
    hiragana: '',
    romaji: '',
    typingChars: [] as TypingChar[],
    displayChars: [] as string[]
  });
  
  // ユーザーの入力
  const [userInput, setUserInput] = useState('');
  
  // 現在の文字位置（かなのインデックス）
  const [currentKanaIndex, setCurrentKanaIndex] = useState(0);
  
  // 表示するステータス
  const [gameStatus, setGameStatus] = useState<'ready' | 'playing' | 'finished'>('ready');

  // 現在のかな文字の表示情報
  const [currentKanaDisplay, setCurrentKanaDisplay] = useState({
    acceptedText: '',
    remainingText: '',
    displayText: ''
  });

  // アニメーションフレーム用のref
  const requestRef = useRef<number | undefined>(undefined);
  const previousTimeRef = useRef<number | undefined>(undefined);
  
  // キー入力キューのref
  const keyInputQueueRef = useRef<string[]>([]);

  // 表示用の状態をrefで管理し、レンダリングの最適化
  const gameStateRef = useRef({
    currentKanaIndex: 0,
    typingChars: [] as TypingChar[],
    currentPosition: 0,
    gameStatus: 'ready' as 'ready' | 'playing' | 'finished',
  });
  
  // スコア記録用
  const [score, setScore] = useState(null);
  const typingResultsRef = useRef([]);
  const [keyCount, setKeyCount] = useState(0);
  const [missCount, setMissCount] = useState(0);
  const [correctCount, setCorrectCount] = useState(0);
  const wordStartTimeRef = useRef(0);
  const [hasStarted, setHasStarted] = useState(false);

  // スコア表示用の状態
  const [scoreLog, setScoreLog] = useState<PerWordScoreLog[]>([]);
  const [resultScore, setResultScore] = useState<GameScoreLog['total'] | null>(null);
  // 1問ごとの計測用ref
  const wordKeyCountRef = useRef(0);
  const wordCorrectRef = useRef(0);
  const wordMissRef = useRef(0);

  // お題をセットアップ - 最適化版
  useEffect(() => {
    if (wordList.length > 0) {
      const word = wordList[currentWordIndex];
      // タイピング文字オブジェクトの配列を作成
      const typingChars = createTypingChars(word.hiragana);
      // 表示用のローマ字の配列を作成
      const displayChars = typingChars.map(char => char.getDisplayInfo().displayText);
      
      setCurrentWord({
        japanese: word.japanese,
        hiragana: word.hiragana,
        romaji: displayChars.join(''),
        typingChars: typingChars,
        displayChars: displayChars
      });
      
      // refを使って状態を管理
      gameStateRef.current = {
        ...gameStateRef.current,
        typingChars: typingChars,
        currentKanaIndex: 0,
        currentPosition: 0
      };

      setUserInput('');
      setCurrentKanaIndex(0);
      
      if (typingChars.length > 0) {
        const currentInfo = typingChars[0].getDisplayInfo();
        setCurrentKanaDisplay({
          acceptedText: currentInfo.acceptedText,
          remainingText: currentInfo.remainingText,
          displayText: currentInfo.displayText
        });
      }
    }
  }, [currentWordIndex]);
  
  // お題開始時に時刻記録
  useEffect(() => {
    if (gameStatus === 'playing') {
      wordStartTimeRef.current = 0;
    }
  }, [gameStatus]);

  // お題切り替え時に開始時刻セット
  useEffect(() => {
    if (gameStatus === 'playing') {
      wordStartTimeRef.current = performance.now();
    }
  }, [currentWordIndex, gameStatus]);

  // キー入力のバッファ処理 (KPM計測付き)
  const processKeyInputQueue = useCallback(() => {
    while (keyInputQueueRef.current.length > 0 && gameStateRef.current.gameStatus === 'playing') {
      const key = keyInputQueueRef.current.shift();
      if (!key) continue;
      // 最初のキー入力時刻を記録
      if (wordStartTimeRef.current === null) {
        wordStartTimeRef.current = Date.now();
      }
      wordKeyCountRef.current++;
      // 現在入力中のかな文字オブジェクト
      const currentTypingChar = gameStateRef.current.typingChars[gameStateRef.current.currentKanaIndex];
      if (!currentTypingChar) continue;
      
      // 入力処理
      if (currentTypingChar.canAccept(key)) {
        currentTypingChar.accept(key);
        wordCorrectRef.current++;
        
        // 表示情報の更新
        setCurrentKanaDisplay({
          acceptedText: currentTypingChar.getDisplayInfo().acceptedText,
          remainingText: currentTypingChar.getDisplayInfo().remainingText,
          displayText: currentTypingChar.getDisplayInfo().displayText
        });
        setUserInput(prev => prev + key);
        
        // かなが完了したかチェック
        if (currentTypingChar.getDisplayInfo().isCompleted) {
          const nextIndex = gameStateRef.current.currentKanaIndex + 1;
          gameStateRef.current.currentKanaIndex = nextIndex;
          setCurrentKanaIndex(nextIndex);
          if (nextIndex < gameStateRef.current.typingChars.length) {
            const nextInfo = gameStateRef.current.typingChars[nextIndex].getDisplayInfo();
            setCurrentKanaDisplay({
              acceptedText: nextInfo.acceptedText,
              remainingText: nextInfo.remainingText,
              displayText: nextInfo.displayText
            });
          } else {
            // 1問分のスコア記録
            if (currentWordIndex + 1 < wordList.length) {
              handleWordFinish();
              setTimeout(() => {
                setCurrentWordIndex(prev => prev + 1);
              }, 500);
            } else {
              // 最後のスコア記録をpushし終わった後にゲーム終了
              setScoreLog(prev => {
                const newLog = [...prev, {
                  keyCount: wordKeyCountRef.current,
                  correct: wordCorrectRef.current,
                  miss: wordMissRef.current,
                  startTime: wordStartTimeRef.current,
                  endTime: Date.now(),
                  duration: 0,
                  kpm: 0,
                  accuracy: 0
                }];
                // pushが終わった直後にゲーム終了
                setTimeout(() => {
                  setGameStatus('finished');
                  gameStateRef.current.gameStatus = 'finished';
                }, 0);
                return newLog;
              });
              wordKeyCountRef.current = 0;
              wordCorrectRef.current = 0;
              wordMissRef.current = 0;
              wordStartTimeRef.current = 0;
            }
          }
        }
      } else {
        wordMissRef.current++;
      }
    }
  }, [currentWordIndex]);

  // アニメーションループ
  const animationLoop = useCallback((time: number) => {
    if (previousTimeRef.current === undefined) {
      previousTimeRef.current = time;
    }
    
    // キー入力キューを処理
    processKeyInputQueue();
    
    // 次のフレームを要求
    requestRef.current = requestAnimationFrame(animationLoop);
  }, [processKeyInputQueue]);
  
  // ゲーム開始時にキーボードイベントをセット & アニメーションフレームを開始
  useEffect(() => {
    // 軽量化したキーダウンハンドラ
    const keyDownHandler = (e: KeyboardEvent) => {
      const status = gameStateRef.current.gameStatus;
      
      // ゲームがプレイ中でない場合はスペースキーでスタート
      if (status !== 'playing') {
        if (e.key === ' ' || e.code === 'Space') {
          e.preventDefault();
          setGameStatus('playing');
          gameStateRef.current.gameStatus = 'playing';
        }
        return;
      }

      // ESCキーでゲームリセット
      if (e.key === 'Escape') {
        resetGame();
        return;
      }

      // 入力可能キーの場合はキューに追加
      if (e.key.length === 1) {
        keyInputQueueRef.current.push(e.key);
      }
    };
    
    window.addEventListener('keydown', keyDownHandler);
    requestRef.current = requestAnimationFrame(animationLoop);
    
    return () => {
      window.removeEventListener('keydown', keyDownHandler);
      if (requestRef.current) {
        cancelAnimationFrame(requestRef.current);
      }
    };
  }, [animationLoop]);

  // ゲームをリセット
  const resetGame = useCallback(() => {
    setCurrentWordIndex(0);
    setUserInput('');
    setCurrentKanaIndex(0);
    setGameStatus('ready');
    setScore(null);
    setScoreLog([]);
    wordKeyCountRef.current = 0;
    wordCorrectRef.current = 0;
    wordMissRef.current = 0;
    wordStartTimeRef.current = 0;
  }, []);

  // 各文字のスタイルを決定（かな単位ではなく、表示テキスト単位）
  const getCharClass = useCallback((kanaIndex: number, charIndex: number, char: string) => {
    if (kanaIndex < currentKanaIndex) {
      return styles.completed; // 入力済みのかな
    } else if (kanaIndex === currentKanaIndex) {
      const currentInfo = currentWord.typingChars[kanaIndex]?.getDisplayInfo();
      if (currentInfo) {
        const acceptedLength = currentInfo.acceptedText.length;
        
        if (charIndex < acceptedLength) {
          return styles.completed; // 入力済みの文字
        } else if (charIndex === acceptedLength) {
          return styles.current; // 現在の文字
        }
      }
    }
    return styles.pending; // 未入力
  }, [currentKanaIndex, currentWord.typingChars]);

  // メモ化されたレンダリングコンポーネント
  const renderTypingArea = useCallback(() => {
    return (
      <>
        {currentWord.typingChars.map((typingChar, kanaIndex) => {
          // 各かなに対応するローマ字表示
          const displayText = currentWord.displayChars[kanaIndex] || '';
          
          return (
            <span key={kanaIndex} className={styles.kanaGroup}>
              {displayText.split('').map((char, charIndex) => (
                <span 
                  key={`${kanaIndex}-${charIndex}`} 
                  className={getCharClass(kanaIndex, charIndex, char)}
                >
                  {char}
                </span>
              ))}
            </span>
          );
        })}
      </>
    );
  }, [currentWord, currentKanaIndex, currentKanaDisplay, getCharClass]);

  // お題クリア時にスコア記録
  const handleWordFinish = useCallback(() => {
    if (wordStartTimeRef.current) {
      setScoreLog(prev => [...prev, {
        keyCount: wordKeyCountRef.current,
        correct: wordCorrectRef.current,
        miss: wordMissRef.current,
        startTime: wordStartTimeRef.current,
        endTime: Date.now(),
        duration: 0,
        kpm: 0,
        accuracy: 0
      }]);
    }
    wordKeyCountRef.current = 0;
    wordCorrectRef.current = 0;
    wordMissRef.current = 0;
    wordStartTimeRef.current = 0;
  }, []);

  // ゲーム終了時にスコア計算
  useEffect(() => {
    if (gameStatus === 'finished' && scoreLog.length === wordList.length) {
      calcScoreWithWorker({ results: scoreLog }).then(setScore);
    }
  }, [gameStatus, scoreLog]);

  return (
    <>
      <div className={styles.typingGameContainer}>
        {gameStatus === 'ready' && (
          <div className={styles.startScreen}>
            <h2>タイピングゲーム</h2>
            <p>スペースキーを押してスタート</p>
          </div>
        )}

        {gameStatus === 'playing' && (
          <div className={styles.gameScreen}>
            <div className={styles.wordJapanese}>{currentWord.japanese}</div>
            <div className={styles.wordHiragana}>{currentWord.hiragana}</div>
            <div className={styles.typingArea}>{renderTypingArea()}</div>
            <div className={styles.progress}>
              お題: {currentWordIndex + 1} / {wordList.length}
            </div>
          </div>
        )}

        {gameStatus === 'finished' && (
          <div className={styles.finishScreen}>
            <h2>リザルト画面</h2>
            <div className={styles.scoreBoard}>
              {score ? <>
                <div>KPM<br /><span>{score.kpm}</span></div>
                <div>Accuracy<br /><span>{score.accuracy}%</span></div>
                <div>Correct<br /><span>{score.correct}</span></div>
                <div>Miss<br /><span>{score.miss}</span></div>
              </> : <div>計算中...</div>}
            </div>
            <button onClick={resetGame} className={styles.resetButton}>
              もう一度プレイ
            </button>
            <button onClick={onGoRanking} className={styles.resetButton} style={{marginTop: 12, background: '#06b6d4'}}>ランキングへ</button>
            <button onClick={onGoMenu} className={styles.resetButton} style={{marginTop: 12, background: '#334155'}}>メニューへ</button>
          </div>
        )}
      </div>
      <div className={styles.mcpStatusWrapper}>
        <MCPStatus position="bottom-right" />
      </div>
    </>
  );
};

export default TypingGame;
