'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import { useGameStatus, useTypingGameStore, useCurrentWord } from '@/store/typingGameStore';
import { useAudioStore } from '@/store/audioStore';
import { TypingWord, KanaDisplay } from '@/types/typing';
import { useTypingGameLifecycle } from '@/hooks/useTypingGameLifecycle';
import MCPStatus from '@/components/MCPStatus';
import GameScreen from '@/components/GameScreen';
import RankingScreen from '@/components/RankingScreen';
import styles from '@/styles/TypingGame.module.css';
import type { PerWordScoreLog, GameScoreLog } from '@/types/score';
import { useRouter } from 'next/navigation';
import KeyboardSoundUtils from '@/utils/KeyboardSoundUtils';
import { saveRanking, initializeFirebase } from '@/utils/FirebaseUtils';

// --- Web Workerã‚¹ã‚³ã‚¢è¨ˆç®—ãƒ©ãƒƒãƒ‘ãƒ¼ ---
let scoreWorker: Worker | null = null;
function getScoreWorker() {
  if (!scoreWorker) {
    scoreWorker = new Worker(new URL('@/workers/scoreWorker.ts', import.meta.url));
  }
  return scoreWorker;
}
function calcScoreWithWorker(payload: any): Promise<any> {
  return new Promise((resolve) => {
    const worker = getScoreWorker();
    const handleMessage = (e: MessageEvent<any>) => {
      if (e.data.type === 'scoreResult') {
        resolve(e.data.payload);
        worker.removeEventListener('message', handleMessage);
      }
    };
    worker.addEventListener('message', handleMessage);
    worker.postMessage({ type: 'calcScore', payload });
  });
}

const TypingGame: React.FC<{ onGoMenu?: () => void; onGoRanking?: () => void }> = ({ onGoMenu, onGoRanking }) => {
  const router = useRouter();
  // Zustandã‚¹ãƒˆã‚¢ã‹ã‚‰ã€ŒãŠé¡Œæƒ…å ±ã€ã€Œã‚²ãƒ¼ãƒ çŠ¶æ…‹ã€ã ã‘è³¼èª­
  const gameStatus = useGameStatus();
  const { setGameStatus, advanceToNextWord, resetGame, setupCurrentWord } = useTypingGameStore();
  const storeWord = useCurrentWord();
  const { playSound } = useAudioStore();
  useTypingGameLifecycle();
  
  // FirebaseåˆæœŸåŒ–
  useEffect(() => {
    initializeFirebase();
  }, []);
  
  // typingmania-refæµ: é€²è¡ŒçŠ¶æ…‹ã¯useRefã§ç®¡ç†
  const typingCharsRef = useRef<TypingWord['typingChars']>([]);
  const displayCharsRef = useRef<TypingWord['displayChars']>([]);
  const kanaIndexRef = useRef<number>(0);

  // ç”»é¢è¡¨ç¤ºç”¨ã®ã¿useState
  const [kanaDisplay, setKanaDisplay] = useState<KanaDisplay>({
    acceptedText: '',
    remainingText: '',
    displayText: ''
  });
  const [currentWord, setCurrentWord] = useState<TypingWord>({
    japanese: '',
    hiragana: '',
    romaji: '',
    typingChars: [],
    displayChars: []
  });

  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²ç”¨
  const [playerName, setPlayerName] = useState<string>('');
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [submitSuccess, setSubmitSuccess] = useState<boolean>(false);
  const [difficulty, setDifficulty] = useState<string>('normal');

  // æœ€çµ‚ã‚¹ã‚³ã‚¢ç®¡ç†
  const [lastScore, setLastScore] = useState<{
    playerName?: string;
    kpm: number;
    accuracy: number;
    time: number;
    mistakes: number;
  } | null>(null);

  // ã‚¹ã‚³ã‚¢è¨˜éŒ²
  const [scoreLog, setScoreLog] = useState<PerWordScoreLog[]>([]);
  const [resultScore, setResultScore] = useState<GameScoreLog['total'] | null>(null);
  const wordKeyCountRef = useRef(0);
  const wordCorrectRef = useRef(0);
  const wordMissRef = useRef(0);
  const wordStartTimeRef = useRef<number>(0);

  // ãŠé¡Œåˆ‡ã‚Šæ›¿ãˆæ™‚ã®ã¿useRefã‚’åˆæœŸåŒ–
  useEffect(() => {
    if (storeWord && storeWord.japanese !== currentWord.japanese) {
      setCurrentWord(storeWord);
      typingCharsRef.current = storeWord.typingChars;
      displayCharsRef.current = storeWord.displayChars;
      kanaIndexRef.current = 0;
      if (storeWord.typingChars.length > 0) {
        const info = storeWord.typingChars[0].getDisplayInfo();
        setKanaDisplay({
          acceptedText: info.acceptedText,
          remainingText: info.remainingText,
          displayText: info.displayText
        });
      }
      // ãŠé¡Œåˆ‡ã‚Šæ›¿ãˆæ™‚ã«ã‚¹ã‚³ã‚¢è¨˜éŒ²ç”¨refã‚‚ãƒªã‚»ãƒƒãƒˆ
      wordKeyCountRef.current = 0;
      wordCorrectRef.current = 0;
      wordMissRef.current = 0;
      wordStartTimeRef.current = 0;
    }
  }, [storeWord]);

  // typingmania-refæµ: ã‚­ãƒ¼å…¥åŠ›ã¯useRefã‚’ç›´æ¥ãƒŸãƒ¥ãƒ¼ãƒ†ãƒ¼ãƒˆ
  useEffect(() => {
    if (gameStatus !== 'playing') return;
    const keyDownHandler = (e: KeyboardEvent) => {
      if (gameStatus !== 'playing') return;
      if (e.key === 'Escape') {
        router.push('/'); // ESCã§ãƒ¡ã‚¤ãƒ³ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã«é·ç§»
        return;
      }
      if (e.key.length !== 1) return;
      const typingChars = typingCharsRef.current;
      const idx = kanaIndexRef.current;
      const currentTypingChar = typingChars[idx];
      if (!currentTypingChar) return;
      if (wordKeyCountRef.current === 0) {
        wordStartTimeRef.current = Date.now();
      }
      wordKeyCountRef.current++;
      if (currentTypingChar.canAccept(e.key)) {
        currentTypingChar.accept(e.key);
        wordCorrectRef.current++;
        // --- ã“ã“ã‚’Web Audio APIåˆæˆéŸ³ã«å·®ã—æ›¿ãˆ ---
        KeyboardSoundUtils.playClickSound();
        // ---
        const info = currentTypingChar.getDisplayInfo();
        setKanaDisplay({
          acceptedText: info.acceptedText,
          remainingText: info.remainingText,
          displayText: info.displayText
        });
        // ã‹ãªãŒå®Œäº†ã—ãŸã‚‰æ¬¡ã¸
        if (info.isCompleted) {
          const nextIdx = idx + 1;
          kanaIndexRef.current = nextIdx;
          if (nextIdx < typingChars.length) {
            const nextInfo = typingChars[nextIdx].getDisplayInfo();
            setKanaDisplay({
              acceptedText: nextInfo.acceptedText,
              remainingText: nextInfo.remainingText,
              displayText: nextInfo.displayText
            });
          } else {
            // 1å•åˆ†ã®ã‚¹ã‚³ã‚¢è¨˜éŒ²
            const now = Date.now();
            const durationMs = now - wordStartTimeRef.current;
            const durationSec = durationMs / 1000;
            let wordKpm = 0;
            let wordAccuracy = 0;
            
            if (durationSec > 0) {
              wordKpm = Math.round((wordKeyCountRef.current / durationSec) * 60 * 10) / 10;
            }
            
            const totalInput = wordCorrectRef.current + wordMissRef.current;
            if (totalInput > 0) {
              wordAccuracy = Math.round((wordCorrectRef.current / totalInput) * 1000) / 10;
            }
            
            setScoreLog(prev => [...prev, {
              keyCount: wordKeyCountRef.current,
              correct: wordCorrectRef.current,
              miss: wordMissRef.current,
              startTime: wordStartTimeRef.current,
              endTime: now,
              duration: durationSec,
              kpm: wordKpm,
              accuracy: wordAccuracy
            }]);
            setTimeout(() => {
              advanceToNextWord();
            }, 300);
          }
        }
      } else {
        wordMissRef.current++;
        // --- ã“ã“ã‚‚Web Audio APIåˆæˆéŸ³ã«å·®ã—æ›¿ãˆ ---
        KeyboardSoundUtils.playErrorSound();
        // ---
      }
    };
    window.addEventListener('keydown', keyDownHandler);
    return () => window.removeEventListener('keydown', keyDownHandler);
  }, [gameStatus, advanceToNextWord, router]);

  // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹
  useEffect(() => {
    if (gameStatus !== 'ready') return;
    const keyDownHandler = (e: KeyboardEvent) => {
      if (gameStatus === 'ready' && (e.key === ' ' || e.code === 'Space')) {
        e.preventDefault();
        setGameStatus('playing');
      }
    };
    window.addEventListener('keydown', keyDownHandler);
    return () => window.removeEventListener('keydown', keyDownHandler);
  }, [gameStatus, setGameStatus]);

  // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã«ã‚¹ã‚³ã‚¢è¨ˆç®—
  useEffect(() => {
    if (gameStatus === 'finished' && scoreLog.length > 0) {
      console.log('ã‚¹ã‚³ã‚¢è¨ˆç®—é–‹å§‹', scoreLog);
      
      try {
        // å‹å¤‰æ›ã¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£åã®ä¿®æ­£ã‚’æ˜ç¤ºçš„ã«è¡Œã†
        const mappedData = scoreLog.map(log => {
          // nullãƒã‚§ãƒƒã‚¯ã¨å‹å¤‰æ›ã‚’è¡Œã„ã€WorkerãŒè¦æ±‚ã™ã‚‹å½¢å¼ã«åˆã‚ã›ã‚‹
          const missCount = typeof log.miss === 'number' ? log.miss : 0;
          const correctCount = typeof log.correct === 'number' ? log.correct : 0;
          
          return {
            keyCount: log.keyCount,
            missCount: missCount,
            correctCount: correctCount,
            startTime: log.startTime,
            endTime: log.endTime
          };
        });
        
        console.log('Workeré€ä¿¡ãƒ‡ãƒ¼ã‚¿', mappedData);
        
        if (mappedData.length === 0) {
          console.error('ã‚¹ã‚³ã‚¢ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚Šã¾ã›ã‚“');
          setResultScore({ kpm: 0, accuracy: 0, correct: 0, miss: 0 });
          return;
        }
        
        calcScoreWithWorker({ results: mappedData })
          .then(result => {
            console.log('Workerçµæœ', result);
            if (result && typeof result === 'object') {
              // çµæœã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
              const validatedResult = {
                kpm: typeof result.kpm === 'number' ? result.kpm : 0,
                accuracy: typeof result.accuracy === 'number' ? result.accuracy : 0,
                correct: typeof result.correct === 'number' ? result.correct : 0,
                miss: typeof result.miss === 'number' ? result.miss : 0,
              };
              setResultScore(validatedResult);
            } else {
              console.error('ä¸æ­£ãªçµæœå½¢å¼', result);
              setResultScore({ kpm: 0, accuracy: 0, correct: 0, miss: 0 });
            }
          })
          .catch(error => {
            console.error('ã‚¹ã‚³ã‚¢è¨ˆç®—ã‚¨ãƒ©ãƒ¼', error);
            setResultScore({ kpm: 0, accuracy: 0, correct: 0, miss: 0 });
          });
      } catch (e) {
        console.error('ã‚¹ã‚³ã‚¢è¨ˆç®—ã®æº–å‚™ä¸­ã«ã‚¨ãƒ©ãƒ¼', e);
        setResultScore({ kpm: 0, accuracy: 0, correct: 0, miss: 0 });
      }
    }
  }, [gameStatus, scoreLog]);

  // /gameç›´ã‚¢ã‚¯ã‚»ã‚¹æ™‚ã®ã¿ãƒªãƒ€ã‚¤ãƒ¬ã‚¯ãƒˆï¼ˆåˆå›ãƒã‚¦ãƒ³ãƒˆæ™‚ã«ä¸€åº¦ã ã‘åˆ¤å®šï¼‰
  useEffect(() => {
    if (typeof window !== 'undefined') {
      const isDirectAccess = window.location.pathname === '/game';
      const fromMenu = sessionStorage.getItem('fromMenu');
      if (isDirectAccess && !fromMenu) {
        router.replace('/');
      }
      if (fromMenu) {
        sessionStorage.removeItem('fromMenu'); // ä¸€åº¦ã ã‘æ¶ˆã™
      }
    }
    // eslint-disable-next-line
  }, []); // åˆå›ãƒã‚¦ãƒ³ãƒˆæ™‚ã®ã¿åˆ¤å®š

  // çµæœãŒå‡ºãŸã¨ãã«lastScoreã‚’æ›´æ–°
  useEffect(() => {
    if (gameStatus === 'finished' && resultScore) {
      setLastScore({
        playerName: playerName || undefined,
        kpm: resultScore.kpm,
        accuracy: resultScore.accuracy,
        time: 60, // ã‚²ãƒ¼ãƒ æ™‚é–“ã¯60ç§’ã¨ä»®å®š
        mistakes: resultScore.miss
      });
    }
  }, [gameStatus, resultScore, playerName]);

  // ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
  const handleReset = useCallback(() => {
    resetGame();
    setScoreLog([]);
    setResultScore(null);
    setSubmitSuccess(false);
    setLastScore(null);
  }, [resetGame]);

  // ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ç™»éŒ²ã™ã‚‹
  const handleSubmitRanking = async () => {
    if (!resultScore || !playerName.trim() || isSubmitting) return;
    
    setIsSubmitting(true);
    try {
      await saveRanking(
        playerName.trim(),
        resultScore.kpm,
        resultScore.accuracy,
        60, // ã‚²ãƒ¼ãƒ æ™‚é–“ã¯60ç§’ã¨ä»®å®š
        resultScore.miss,
        difficulty
      );
      setSubmitSuccess(true);
      playSound('correct');
    } catch (error) {
      console.error('ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²ã‚¨ãƒ©ãƒ¼:', error);
      playSound('wrong');
    } finally {
      setIsSubmitting(false);
    }
  };  // ç”»é¢åˆ†å‰²ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°
  return (
    <div className={styles.typingGameContainer}>
      {/* ã‚¹ã‚¿ãƒ¼ãƒˆç”»é¢ */}
      {gameStatus === 'ready' && (
        <div className={styles.startScreen}>
          <h2>ã‚¿ã‚¤ãƒ”ãƒ³ã‚°ã‚²ãƒ¼ãƒ </h2>
          <p>ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆ</p>
        </div>
      )}
      
      {/* ã‚²ãƒ¼ãƒ ç”»é¢ */}
      {gameStatus === 'playing' && (
        <GameScreen
          currentWord={currentWord}
          currentKanaIndex={kanaIndexRef.current}
          currentKanaDisplay={kanaDisplay}
        />
      )}
      
      {/* ãƒªã‚¶ãƒ«ãƒˆç”»é¢ */}
      {gameStatus === 'finished' && (
        <div className={styles.finishScreen}>
          <h2>ãƒªã‚¶ãƒ«ãƒˆç”»é¢</h2>
          <div className={styles.scoreBoard}>
            {resultScore ? <>
              <div>KPM<br /><span>{resultScore.kpm}</span></div>
              <div>Accuracy<br /><span>{resultScore.accuracy}%</span></div>
              <div>Correct<br /><span>{resultScore.correct}</span></div>
              <div>Miss<br /><span>{resultScore.miss}</span></div>
            </> : 
            gameStatus === 'finished' && scoreLog.length > 0 ? (
              // 10ç§’ä»¥ä¸ŠçµŒéã—ã¦ã‚‚ã‚¹ã‚³ã‚¢ãŒè¨ˆç®—ã•ã‚Œãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
              <div className={styles.calculatingScore}>
                è¨ˆç®—ä¸­...
                <button 
                  className={styles.recalcButton}
                  onClick={() => {
                    // å¼·åˆ¶çš„ã«å†è¨ˆç®—ã‚’è©¦ã¿ã‚‹
                    const dummyScore = {
                      kpm: scoreLog.reduce((sum, log) => sum + (log.kpm || 0), 0) / scoreLog.length || 0,
                      accuracy: scoreLog.reduce((sum, log) => sum + (log.accuracy || 0), 0) / scoreLog.length || 0,
                      correct: scoreLog.reduce((sum, log) => sum + (log.correct || 0), 0),
                      miss: scoreLog.reduce((sum, log) => sum + (log.miss || 0), 0)
                    };
                    setResultScore(dummyScore);
                  }}
                >
                  ã‚¹ã‚³ã‚¢ã‚’è¡¨ç¤º
                </button>
              </div>
            ) : (
              <div>è¨ˆç®—ä¸­...</div>
            )}
          </div>
          
          {/* ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²ãƒ•ã‚©ãƒ¼ãƒ  */}
          {resultScore && !submitSuccess ? (
            <div className={styles.rankingForm}>
              <h3>ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ç™»éŒ²</h3>
              <div className={styles.formGroup}>
                <select 
                  value={difficulty} 
                  onChange={(e) => setDifficulty(e.target.value)}
                  className={styles.difficultySelect}
                  disabled={isSubmitting}
                >
                  <option value="easy">ã‚„ã•ã—ã„</option>
                  <option value="normal">ãµã¤ã†</option>
                  <option value="hard">é›£ã—ã„</option>
                </select>
              </div>
              <div className={styles.formGroup}>
                <input
                  type="text"
                  placeholder="ã‚ãªãŸã®åå‰"
                  value={playerName}
                  onChange={(e) => setPlayerName(e.target.value)}
                  maxLength={20}
                  className={styles.nameInput}
                  disabled={isSubmitting}
                />
              </div>
              <button 
                onClick={handleSubmitRanking}
                className={`${styles.resetButton} ${styles.submitButton}`}
                disabled={!playerName.trim() || isSubmitting}
                style={{marginTop: 12, background: '#10b981'}}
              >
                {isSubmitting ? 'é€ä¿¡ä¸­...' : 'ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ç™»éŒ²ã™ã‚‹'}
              </button>
            </div>
          ) : submitSuccess ? (
            <div className={styles.submitSuccess} style={{margin: '15px 0', color: '#10b981', fontWeight: 'bold'}}>
              ğŸ‰ ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã«ç™»éŒ²ã—ã¾ã—ãŸï¼
            </div>
          ) : null}

          <button onClick={handleReset} className={styles.resetButton}>
            ã‚‚ã†ä¸€åº¦ãƒ—ãƒ¬ã‚¤
          </button>
          <button 
            onClick={() => setGameStatus('ranking')} 
            className={styles.resetButton} 
            style={{marginTop: 12, background: '#06b6d4'}}
          >
            ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã¸
          </button>
          <button onClick={onGoMenu} className={styles.resetButton} style={{marginTop: 12, background: '#334155'}}>
            ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã¸
          </button>
        </div>
      )}
      
      {/* ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç”»é¢ */}
      {gameStatus === 'ranking' && (
        <RankingScreen 
          onGoBack={() => setGameStatus('finished')} 
          lastScore={lastScore}
        />
      )}
    </div>
  );
};
    </div>
  );
};

export default TypingGame;
