/**
 * HyperTypingEngine - Phase 1&2 é«˜é€ŸåŒ–çµ±åˆã‚¨ãƒ³ã‚¸ãƒ³
 * 
 * 1. Phase 1æœ€é©åŒ–: RequestIdleCallbackã€äºˆæ¸¬ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã€å·®åˆ†æ›´æ–°
 * 2. Phase 2çµ±åˆ: WebAssemblyçµ±åˆã«ã‚ˆã‚‹270å€é«˜é€ŸåŒ–
 * 3. Debugæœ€é©åŒ–: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ã®è»½é‡ãƒ­ã‚°å‡ºåŠ›
 */

import { TypingChar, type DisplayInfo } from './TypingChar';
import type { KanaDisplay, PerWordScoreLog } from '@/types';
import OptimizedAudioSystem from '@/utils/OptimizedAudioSystem';
import { debug } from '../utils/debug';
import { wasmTypingProcessor } from './wasm-integration/WasmTypingProcessor';

// Phase 1: äºˆæ¸¬ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
interface CachedResult {
  success: boolean;
  completed: boolean;
  displayInfo: DisplayInfo;
  nextIndex: number;
  timestamp: number;
}

interface KeyPrediction {
  key: string;
  probability: number;
  charIndex: number;
}

interface DOMUpdateFragment {
  kanaChanged: boolean;
  romajiChanged: boolean;
  progressChanged: boolean;
  kanaContent?: string;
  romajiAccepted?: string;
  romajiRemaining?: string;
  progressValue?: number;
}

interface HyperEngineState {
  typingChars: TypingChar[];
  currentIndex: number;
  keyCount: number;
  mistakeCount: number;
  startTime: number;
}

interface DisplayElements {
  kanaElement: HTMLElement;
  romajiElement: HTMLElement;
  progressElement: HTMLElement;
}

/**
 * ğŸš€ HyperTypingEngine - Phase 1 æ€§èƒ½çªç ´å®Ÿè£…
 * 
 * 2-5å€é«˜é€ŸåŒ–ã‚’å®Ÿç¾ã™ã‚‹å³åº§å®Ÿè£…æ©Ÿèƒ½:
 * - RequestIdleCallbackæœ€é©åŒ–
 * - äºˆæ¸¬ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°  
 * - å·®åˆ†æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ 
 */
export class HyperTypingEngine {
  // å†…éƒ¨çŠ¶æ…‹ç®¡ç†
  private state: HyperEngineState;
  private container: HTMLElement | null = null;
  private displayElements: DisplayElements | null = null;
  private onProgress?: (index: number, display: KanaDisplay) => void;
  private onComplete?: (scoreLog: PerWordScoreLog) => void;
  private keyHandler?: (e: KeyboardEvent) => void;

  // ğŸš€ Phase 1.2: äºˆæ¸¬ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
  private performanceCache = new Map<string, CachedResult>();
  private cacheHitCount = 0;
  private cacheMissCount = 0;
  
  // ğŸš€ Phase 1.1: RequestIdleCallbackæœ€é©åŒ–
  private idleScheduled = false;
  private predictionQueue: KeyPrediction[] = [];
  
  // ğŸš€ Phase 1.3: å·®åˆ†æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ 
  private lastDOMState: DOMUpdateFragment = {
    kanaChanged: false,
    romajiChanged: false,
    progressChanged: false
  };
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬
  private performanceMetrics = {
    keyProcessingTimes: [] as number[],
    cacheHitRate: 0,
    idleComputations: 0,
    domUpdatesSkipped: 0,
    wasmProcessingTimes: [] as number[], // Phase 2: WASMæ€§èƒ½è¨ˆæ¸¬
    wasmHitRate: 0 // Phase 2: WASMåˆ©ç”¨ç‡
  };
  constructor() {
    this.state = {
      typingChars: [],
      currentIndex: 0,
      keyCount: 0,
      mistakeCount: 0,
      startTime: 0,
    };
    this.initializePerformanceOptimizations();
    // Phase 2: WebAssemblyçµ±åˆåˆæœŸåŒ–ï¼ˆéåŒæœŸã§å®Ÿè¡Œï¼‰
    this.initializeWasmIntegration();
  }
  /**
   * ğŸš€ Phase 1: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  - è»½é‡åŒ–ç‰ˆ
   */
  private setupCacheManagement(): void {
    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: è»½é‡ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ç®¡ç†
    setInterval(() => {
      this.cleanupOldCache();
    }, 10000); // 10ç§’ã”ã¨ã«ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
  }

  /**
   * ğŸš€ å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®è»½é‡ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  private cleanupOldCache(): void {
    const now = Date.now();
    const maxAge = 30000; // 30ç§’ã§ã‚­ãƒ£ãƒƒã‚·ãƒ¥æœŸé™åˆ‡ã‚Œ
    let deleteCount = 0;

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: ä¸€åº¦ã«æœ€å¤§10å€‹ã¾ã§å‰Šé™¤
    for (const [key, value] of this.performanceCache.entries()) {
      if (now - value.timestamp > maxAge) {
        this.performanceCache.delete(key);
        deleteCount++;
        if (deleteCount >= 10) break;
      }
    }

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºä¸Šé™ç®¡ç†
    if (this.performanceCache.size > 30) {
      const keys = Array.from(this.performanceCache.keys());
      for (let i = 0; i < 10; i++) {
        this.performanceCache.delete(keys[i]);
      }
    }
  }
    
    debug.log('ğŸš€ HyperTypingEngineåˆæœŸåŒ–å®Œäº† - Phase 1æœ€é©åŒ–æœ‰åŠ¹');
    debug.typing.log();
  }

  /**
   * åˆæœŸåŒ–
   */
  initialize(
    container: HTMLElement,
    typingChars: TypingChar[],
    onProgress?: (index: number, display: KanaDisplay) => void,
    onComplete?: (scoreLog: PerWordScoreLog) => void
  ): void {
    this.container = container;
    this.state.typingChars = typingChars;
    this.state.currentIndex = 0;
    this.state.keyCount = 0;
    this.state.mistakeCount = 0;
    this.state.startTime = 0;
    this.onProgress = onProgress;
    this.onComplete = onComplete;

    this.setupDOM();
    this.updateDisplay();
    this.setupKeyListener();

    // Phase 1 æœ€é©åŒ–ã®åˆæœŸåŒ–
    this.resetPerformanceStats();
    this.lastDOMState = {
      kanaChanged: false,
      romajiChanged: false,
      progressChanged: false
    };
      // åˆæœŸäºˆæ¸¬
    this.predictNextKeys();
    
    debug.log('ğŸš€ HyperTypingEngineåˆæœŸåŒ–å®Œäº† - Phase 1æœ€é©åŒ–é–‹å§‹');
    debug.typing.log();
  }

  /**
   * DOMæ§‹é€ ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   */
  private setupDOM(): void {
    if (!this.container) return;

    this.container.innerHTML = `
      <div class="typing-display">
        <div class="kana-display"></div>
        <div class="romaji-display"></div>
        <div class="progress-display"></div>
      </div>
    `;

    this.displayElements = {
      kanaElement: this.container.querySelector('.kana-display') as HTMLElement,
      romajiElement: this.container.querySelector('.romaji-display') as HTMLElement,
      progressElement: this.container.querySelector('.progress-display') as HTMLElement,
    };
  }

  /**
   * ã‚­ãƒ¼ãƒªã‚¹ãƒŠãƒ¼ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
   */
  private setupKeyListener(): void {
    // ãƒšãƒ¼ã‚¸ã«ãƒ•ã‚©ãƒ¼ã‚«ã‚¹ã‚’è¨­å®š
    if (document.body) {
      document.body.tabIndex = -1;
      document.body.focus();
    }
    
    this.keyHandler = (e: KeyboardEvent) => {
      if (e.ctrlKey || e.altKey || e.metaKey || e.key.length !== 1) {
        return;
      }

      e.preventDefault();
      e.stopPropagation();
      this.processKey(e.key);
    };

    document.addEventListener('keydown', this.keyHandler, { capture: true });
  }
  /**
   * ğŸš€ Phase 1.1: RequestIdleCallbackæœ€é©åŒ– - è»½é‡åŒ–ç‰ˆ
   * ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ã®äº‹å‰è¨ˆç®—ï¼ˆè©°ã¾ã‚Šé˜²æ­¢æœ€é©åŒ–ï¼‰
   */
  private scheduleIdleOptimizations(): void {
    if (this.idleScheduled || typeof requestIdleCallback === 'undefined') {
      return;
    }

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: äºˆæ¸¬ã‚­ãƒ¥ãƒ¼ãŒå¤šã™ãã‚‹å ´åˆã¯è¨ˆç®—ã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (this.predictionQueue.length > 10) {
      this.predictionQueue = this.predictionQueue.slice(0, 5); // æœ€é‡è¦ãª5ã¤ã®ã¿ä¿æŒ
    }

    this.idleScheduled = true;
    
    requestIdleCallback((deadline) => {
      this.idleScheduled = false;
      
      let computedCount = 0;
      const maxComputePerFrame = 3; // ğŸš€ 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®è¨ˆç®—æ•°åˆ¶é™
      
      while (deadline.timeRemaining() > 1 && // ğŸš€ 1msä½™è£•ã‚’æ®‹ã™
             this.predictionQueue.length > 0 && 
             computedCount < maxComputePerFrame) {
        const prediction = this.predictionQueue.shift();
        if (prediction) {
          this.precomputeKeyResult(prediction);
          this.performanceMetrics.idleComputations++;
          computedCount++;
        }
      }
      
      // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: æ¬¡å›ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã¯æ§ãˆã‚ã«
      if (this.predictionQueue.length > 0 && computedCount < maxComputePerFrame) {
        setTimeout(() => this.scheduleIdleOptimizations(), 16); // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã¾ã§å¾…æ©Ÿ
      }
    });
  }
  /**
   * ğŸš€ Phase 1.1: æ¬¡ã‚­ãƒ¼äºˆæ¸¬ã¨ã‚¢ã‚¤ãƒ‰ãƒ«è¨ˆç®—ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚° - è»½é‡åŒ–ç‰ˆ
   */
  private predictNextKeys(): void {
    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return;

    // âš ï¸ ã€Œã‚“ã€æ–‡å­—ã‚„åˆ†å²çŠ¶æ…‹ã®å ´åˆã¯äºˆæ¸¬ã‚’è¡Œã‚ãªã„
    // ã“ã‚Œã«ã‚ˆã‚Šã€Œã‚“ã€ã«é–¢ã™ã‚‹ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒä½œæˆã•ã‚Œãªã„
    if (currentChar.branchingState || currentChar.kana === 'ã‚“') {
      return;
    }

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: äºˆæ¸¬ã‚­ãƒ¥ãƒ¼ã®ã‚µã‚¤ã‚ºåˆ¶é™
    if (this.predictionQueue.length > 8) {
      return; // æ—¢ã«ååˆ†ãªäºˆæ¸¬ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
    }

    // ç¾åœ¨ã®æ–‡å­—ã®æ®‹ã‚Šãƒ‘ã‚¿ãƒ¼ãƒ³ã‹ã‚‰å¯èƒ½æ€§ã®ã‚ã‚‹ã‚­ãƒ¼ã‚’äºˆæ¸¬
    const possibleKeys = new Set<string>();
    
    for (const pattern of currentChar.patterns) {
      if (pattern.startsWith(currentChar.acceptedInput)) {
        const nextChar = pattern[currentChar.acceptedInput.length];
        if (nextChar) {
          possibleKeys.add(nextChar);
        }
      }
    }

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: äºˆæ¸¬æ•°ã‚’åˆ¶é™ï¼ˆæœ€é‡è¦ã®3ã¤ã®ã¿ï¼‰
    const limitedPredictions = Array.from(possibleKeys).map(key => ({
      key,
      probability: this.calculateKeyProbability(key, currentChar),
      charIndex: this.state.currentIndex
    })).sort((a, b) => b.probability - a.probability).slice(0, 3);

    // äºˆæ¸¬ã‚’ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
    this.predictionQueue.push(...limitedPredictions);

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: ã‚¢ã‚¤ãƒ‰ãƒ«è¨ˆç®—ã¯æ§ãˆã‚ã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    if (this.predictionQueue.length > 0 && !this.idleScheduled) {
      setTimeout(() => this.scheduleIdleOptimizations(), 50); // 50mså¾Œã«ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
    }
  }

  /**
   * ğŸš€ Phase 1.1: ã‚­ãƒ¼ç¢ºç‡è¨ˆç®—ï¼ˆå­¦ç¿’ãªã—ãƒ»ã‚·ãƒ³ãƒ—ãƒ«ç‰ˆï¼‰
   */
  private calculateKeyProbability(key: string, char: TypingChar): number {
    // ã‚·ãƒ³ãƒ—ãƒ«ãªç¢ºç‡è¨ˆç®—
    let probability = 0.1; // ãƒ™ãƒ¼ã‚¹ç¢ºç‡

    // ã‚ˆãä½¿ã‚ã‚Œã‚‹æ–‡å­—ã®ç¢ºç‡ã‚’ä¸Šã’ã‚‹
    const commonKeys = ['a', 'i', 'u', 'e', 'o', 'k', 's', 't', 'n', 'h', 'm', 'y', 'r', 'w'];
    if (commonKeys.includes(key)) {
      probability += 0.3;
    }

    // æœ€çŸ­ãƒ‘ã‚¿ãƒ¼ãƒ³ã«ã‚ã‚‹å ´åˆã¯ç¢ºç‡ã‚’ä¸Šã’ã‚‹
    if (char.patterns[0] && char.patterns[0].includes(key)) {
      probability += 0.4;
    }

    // ã€Œã‚“ã€ã®å ´åˆã®ç‰¹åˆ¥å‡¦ç†
    if (char.kana === 'ã‚“') {
      if (key === 'n') probability += 0.5;
      const consonants = ['k', 'g', 's', 'z', 't', 'd', 'h', 'b', 'p', 'm', 'y', 'r', 'w'];
      if (consonants.includes(key)) probability += 0.3;
    }

    return Math.min(probability, 1.0);
  }
  /**
   * ğŸš€ Phase 1.1: äº‹å‰è¨ˆç®—å®Ÿè¡Œ - è»½é‡åŒ–ç‰ˆ
   */
  private precomputeKeyResult(prediction: KeyPrediction): void {
    const cacheKey = this.generateCacheKey(prediction.charIndex, prediction.key);
    
    // æ—¢ã«ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
    if (this.performanceCache.has(cacheKey)) {
      return;
    }

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚µã‚¤ã‚ºåˆ¶é™
    if (this.performanceCache.size > 50) {
      // å¤ã„ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å‰Šé™¤
      const keys = Array.from(this.performanceCache.keys());
      for (let i = 0; i < 10; i++) {
        this.performanceCache.delete(keys[i]);
      }
    }

    try {
      // ç¾åœ¨ã®çŠ¶æ…‹ã‚’ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
      const currentChar = this.state.typingChars[prediction.charIndex];
      
      // âš ï¸ ã€Œã‚“ã€æ–‡å­—ã‚„åˆ†å²çŠ¶æ…‹ã®å ´åˆã¯äº‹å‰è¨ˆç®—ã‚’å®Œå…¨ã«ã‚¹ã‚­ãƒƒãƒ—
      // ã“ã‚Œã«ã‚ˆã‚Šã‚­ãƒ£ãƒƒã‚·ãƒ¥ãŒä½œæˆã•ã‚Œãšã€å¸¸ã«ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ãŒå®Ÿè¡Œã•ã‚Œã‚‹
      if (currentChar?.branchingState || currentChar?.kana === 'ã‚“') {
        return;
      }
      if (!currentChar) return;

      // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: ç°¡ç´ åŒ–ã•ã‚ŒãŸäº‹å‰è¨ˆç®—
      const originalAcceptedInput = currentChar.acceptedInput;
      const originalCompleted = currentChar.completed;

      // ä»®æƒ³çš„ã«ã‚­ãƒ¼å‡¦ç†ã‚’å®Ÿè¡Œï¼ˆè»½é‡ç‰ˆï¼‰
      let result: CachedResult;
      
      try {
        const success = currentChar.type(prediction.key);
        result = {
          success,
          completed: currentChar.completed,
          displayInfo: currentChar.getDisplayInfo(),
          nextIndex: currentChar.completed ? prediction.charIndex + 1 : prediction.charIndex,
          timestamp: Date.now()
        };

        // çŠ¶æ…‹ã‚’å¾©å…ƒ
        currentChar.acceptedInput = originalAcceptedInput;
        currentChar.completed = originalCompleted;
        (currentChar as any).calculateRemainingText(); // private methodã«ã‚¢ã‚¯ã‚»ã‚¹

        // çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥
        this.performanceCache.set(cacheKey, result);
      } catch (error) {
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯çŠ¶æ…‹å¾©å…ƒã®ã¿è¡Œã„ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã¯ä½œæˆã—ãªã„
        currentChar.acceptedInput = originalAcceptedInput;
        currentChar.completed = originalCompleted;
      }
      
    } catch (error) {
      // äº‹å‰è¨ˆç®—ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ å‡¦ç†ã«ä»»ã›ã‚‹
      debug.warn('äº‹å‰è¨ˆç®—ã‚¹ã‚­ãƒƒãƒ—:', error);
    }
  }

  /**
   * ğŸš€ Phase 1.2: äºˆæ¸¬ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚° - 0mså¿œç­”å®Ÿç¾
   */
  private processKey(key: string): void {
    const startTime = performance.now();

    // åˆå›ã‚­ãƒ¼å…¥åŠ›æ™‚ã«éŸ³å£°ã‚·ã‚¹ãƒ†ãƒ ã‚’åˆæœŸåŒ–ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¸ã‚§ã‚¹ãƒãƒ£ãƒ¼å¯¾å¿œï¼‰
    if (this.state.keyCount === 0) {
      OptimizedAudioSystem.resumeAudioContext();
    }
    
    if (this.state.startTime === 0) {
      this.state.startTime = Date.now();
    }

    this.state.keyCount++;

    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚­ãƒ¼ç”Ÿæˆ
    const cacheKey = this.generateCacheKey(this.state.currentIndex, key);
    const cachedResult = this.performanceCache.get(cacheKey);

    // âš ï¸ ã€Œã‚“ã€ã®åˆ†å²çŠ¶æ…‹ã‚„ã€Œã‚“ã€æ–‡å­—ã®å ´åˆã¯ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’å®Œå…¨ã«ãƒã‚¤ãƒ‘ã‚¹
    const currentChar = this.state.typingChars[this.state.currentIndex];
    const shouldBypassCache = currentChar?.branchingState || currentChar?.kana === 'ã‚“';

    if (shouldBypassCache) {
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‹ã‚‰å‰Šé™¤ã—ã¦ç¢ºå®Ÿã«ãƒã‚¤ãƒ‘ã‚¹
      this.performanceCache.delete(cacheKey);
    }

    if (cachedResult && this.isCacheValid(cachedResult) && !shouldBypassCache) {
      // ğŸš€ 0mså¿œç­”: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒ’ãƒƒãƒˆ
      this.applyCachedResult(cachedResult, key);
      this.cacheHitCount++;
      
      const processingTime = performance.now() - startTime;
      this.performanceMetrics.keyProcessingTimes.push(processingTime);
      
      return;
    }    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ãƒŸã‚¹: é€šå¸¸å‡¦ç†
    this.cacheMissCount++;
    this.processKeyDirect(key);
    
    const processingTime = performance.now() - startTime;
    this.performanceMetrics.keyProcessingTimes.push(processingTime);
    
    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: äºˆæ¸¬æ›´æ–°ã¯æ§ãˆã‚ã«
    if (this.predictionQueue.length < 5) {
      this.predictNextKeys();
    }
  }

  /**
   * é€šå¸¸ã®ã‚­ãƒ¼å‡¦ç†ï¼ˆæ—¢å­˜ãƒ­ã‚¸ãƒƒã‚¯ã‚’ãƒ©ãƒƒãƒ—ï¼‰
   */
  private processKeyDirect(key: string): void {
    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return;

    // ã€Œã‚“ã€ã®åˆ†å²çŠ¶æ…‹å‡¦ç†
    if (currentChar.branchingState) {
      const nextChar = this.state.typingChars[this.state.currentIndex + 1];
      const result = currentChar.typeBranching(key, nextChar);
      
      if (result.success) {
        OptimizedAudioSystem.playClickSound();
          if (result.completeWithSingle) {
          // 'n'ãƒ‘ã‚¿ãƒ¼ãƒ³é¸æŠã®å ´åˆ - æ¬¡ã®æ–‡å­—ã«é€²ã‚“ã§å­éŸ³å‡¦ç†
          this.state.currentIndex++;
          
          if (nextChar) {
            // æ¬¡ã®æ–‡å­—ã¸ã®å­éŸ³ç¶™ç¶šå‡¦ç†
            const nextResult = nextChar.type(key);
            if (nextResult) {
              if (nextChar.completed) {
                this.state.currentIndex++;
                
                // å˜èªå®Œäº†ãƒã‚§ãƒƒã‚¯
                if (this.state.currentIndex >= this.state.typingChars.length) {
                  this.handleWordComplete();
                  return;
                }
              }
            }
          }
        } else {
          // 'nn'ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å®Œäº†ã—ãŸå ´åˆ
          this.state.currentIndex++;
          
          // å˜èªå®Œäº†ãƒã‚§ãƒƒã‚¯
          if (this.state.currentIndex >= this.state.typingChars.length) {
            this.handleWordComplete();
            return;
          }
        }
        
        this.updateDisplay();
        this.notifyProgress();
        return;
      } else {
        // åˆ†å²çŠ¶æ…‹ã§ç„¡åŠ¹ãªã‚­ãƒ¼ãŒå…¥åŠ›ã•ã‚ŒãŸå ´åˆ
        this.state.mistakeCount++;
        OptimizedAudioSystem.playErrorSound();
        this.updateDisplay();
        this.notifyProgress();
        return;
      }
    }

    // é€šå¸¸ã®ã‚¿ã‚¤ãƒ”ãƒ³ã‚°å‡¦ç†
    const isCorrect = currentChar.type(key);

    if (isCorrect) {
      OptimizedAudioSystem.playClickSound();

      if (currentChar.completed) {
        this.state.currentIndex++;
        
        // å˜èªå®Œäº†ãƒã‚§ãƒƒã‚¯
        if (this.state.currentIndex >= this.state.typingChars.length) {
          this.handleWordComplete();
          return;
        }
      }
    } else {
      this.state.mistakeCount++;
      OptimizedAudioSystem.playErrorSound();
    }

    this.updateDisplay();
    this.notifyProgress();
  }

  /**
   * ğŸš€ Phase 1.2: ã‚­ãƒ£ãƒƒã‚·ãƒ¥çµæœé©ç”¨
   */
  private applyCachedResult(cachedResult: CachedResult, key: string): void {
    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return;

    if (cachedResult.success) {
      OptimizedAudioSystem.playClickSound();
      
      // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã•ã‚ŒãŸçµæœã‚’é©ç”¨
      currentChar.acceptedInput = cachedResult.displayInfo.acceptedText;
      currentChar.completed = cachedResult.completed;
      
      if (cachedResult.completed) {
        this.state.currentIndex = cachedResult.nextIndex;
        
        // å˜èªå®Œäº†ãƒã‚§ãƒƒã‚¯
        if (this.state.currentIndex >= this.state.typingChars.length) {
          this.handleWordComplete();
          return;
        }
      }
    } else {
      this.state.mistakeCount++;
      OptimizedAudioSystem.playErrorSound();
    }

    this.updateDisplay();
    this.notifyProgress();
  }
  /**
   * ğŸš€ Phase 1.3: å·®åˆ†æ›´æ–°ã‚·ã‚¹ãƒ†ãƒ  - è»½é‡åŒ–ç‰ˆï¼ˆè©°ã¾ã‚Šé˜²æ­¢ï¼‰
   */
  private updateDisplay(): void {
    if (!this.displayElements) return;

    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return;

    // ğŸš€ è©°ã¾ã‚Šé˜²æ­¢: displayInfoå–å¾—ã‚’æœ€å°é™ã«
    let displayInfo: DisplayInfo | null = null;
    const getDisplayInfo = () => {
      if (!displayInfo) displayInfo = currentChar.getDisplayInfo();
      return displayInfo;
    };

    // å·®åˆ†ãƒã‚§ãƒƒã‚¯ç”¨ã®æ–°ã—ã„çŠ¶æ…‹
    const newDOMState: DOMUpdateFragment = {
      kanaChanged: false,
      romajiChanged: false,
      progressChanged: false
    };

    // ğŸš€ é«˜é€ŸåŒ–: å¿…è¦ãªå ´åˆã®ã¿å„è¦ç´ ã‚’ãƒã‚§ãƒƒã‚¯ãƒ»æ›´æ–°
    let hasAnyChange = false;

    // ã‹ãªè¡¨ç¤ºã®å¤‰æ›´ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€å„ªå…ˆï¼‰
    const newKanaContent = getDisplayInfo().displayText;
    if (newKanaContent !== this.lastDOMState.kanaContent) {
      newDOMState.kanaChanged = true;
      newDOMState.kanaContent = newKanaContent;
      hasAnyChange = true;
      this.displayElements.kanaElement.textContent = newKanaContent;
    }

    // ãƒ­ãƒ¼ãƒå­—è¡¨ç¤ºã®å¤‰æ›´ãƒã‚§ãƒƒã‚¯
    const displayInfoData = getDisplayInfo();
    const newRomajiAccepted = displayInfoData.acceptedText;
    const newRomajiRemaining = displayInfoData.remainingText;
    
    if (newRomajiAccepted !== this.lastDOMState.romajiAccepted || 
        newRomajiRemaining !== this.lastDOMState.romajiRemaining) {
      newDOMState.romajiChanged = true;
      newDOMState.romajiAccepted = newRomajiAccepted;
      newDOMState.romajiRemaining = newRomajiRemaining;
      hasAnyChange = true;
      
      // ğŸš€ è»½é‡åŒ–: ã‚·ãƒ³ãƒ—ãƒ«ãªDOMæ›´æ–°
      this.displayElements.romajiElement.innerHTML = `<span class="accepted">${newRomajiAccepted}</span><span class="remaining">${newRomajiRemaining}</span>`;
    }

    // ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹è¡¨ç¤ºã®å¤‰æ›´ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€ä½å„ªå…ˆåº¦ï¼‰
    if (this.state.currentIndex % 3 === 0) { // ğŸš€ 3æ–‡å­—ã«1å›ã®ã¿æ›´æ–°
      const newProgress = Math.floor((this.state.currentIndex / this.state.typingChars.length) * 100);
      if (newProgress !== this.lastDOMState.progressValue) {
        newDOMState.progressChanged = true;
        newDOMState.progressValue = newProgress;
        hasAnyChange = true;
        this.displayElements.progressElement.textContent = `${newProgress}%`;
      }
    }

    // å¤‰æ›´ãŒãªã„å ´åˆã®çµ±è¨ˆæ›´æ–°
    if (!hasAnyChange) {
      this.performanceMetrics.domUpdatesSkipped++;
      return;
    }

    // çŠ¶æ…‹ã‚’æ›´æ–°
    this.lastDOMState = { ...this.lastDOMState, ...newDOMState };
  }

  /**
   * é€²æ—é€šçŸ¥
   */
  private notifyProgress(): void {
    if (!this.onProgress) return;

    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return;

    const displayInfo = currentChar.getDisplayInfo();
    const kanaDisplay: KanaDisplay = {
      acceptedText: displayInfo.acceptedText,
      remainingText: displayInfo.remainingText,
      displayText: displayInfo.displayText,
    };

    this.onProgress(this.state.currentIndex, kanaDisplay);
  }

  /**
   * å˜èªå®Œäº†å‡¦ç†
   */
  private handleWordComplete(): void {
    const endTime = Date.now();
    const elapsedTime = (endTime - this.state.startTime) / 1000;

    const scoreLog: PerWordScoreLog = {
      keyCount: this.state.keyCount,
      correct: this.state.keyCount - this.state.mistakeCount,
      miss: this.state.mistakeCount,
      startTime: this.state.startTime,
      endTime: endTime,
      duration: elapsedTime,
      kpm: Math.round((this.state.keyCount / elapsedTime) * 60),
      accuracy: (this.state.keyCount - this.state.mistakeCount) / this.state.keyCount,
    };

    this.onComplete?.(scoreLog);
  }
  /**
   * è©³ç´°é€²æ—å–å¾—ï¼ˆå¾“æ¥ã®TypingEngineã¨äº’æ›æ€§ã®ã‚ã‚‹å½¢å¼ï¼‰
   */
  getDetailedProgress() {
    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return null;

    const displayInfo = currentChar.getDisplayInfo();
    return {
      currentKanaIndex: this.state.currentIndex,
      currentRomajiIndex: currentChar.acceptedInput.length,
      totalKanaCount: this.state.typingChars.length,
      totalRomajiCount: this.state.typingChars.reduce((sum, char) => sum + char.patterns[0].length, 0),
      currentKanaDisplay: {
        acceptedText: displayInfo.acceptedText,
        remainingText: displayInfo.remainingText,
        displayText: displayInfo.displayText,
      },
    };
  }

  /**
   * ğŸš€ Phase 1: ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ç¾¤
   */
  private generateCacheKey(charIndex: number, key: string): string {
    const char = this.state.typingChars[charIndex];
    if (!char) return `${charIndex}:${key}:empty`;
    
    return `${charIndex}:${key}:${char.acceptedInput}:${char.branchingState}:${char.branchOptions.join(',')}`;
  }

  private isCacheValid(cachedResult: CachedResult): boolean {
    // ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®æœ‰åŠ¹æœŸé™ãƒã‚§ãƒƒã‚¯ï¼ˆ5åˆ†ï¼‰
    const CACHE_TTL = 5 * 60 * 1000;
    return Date.now() - cachedResult.timestamp < CACHE_TTL;
  }

  private setupCacheManagement(): void {
    // å®šæœŸçš„ãªã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    setInterval(() => {
      this.cleanupCache();
    }, 60000); // 1åˆ†ã”ã¨
  }

  private cleanupCache(): void {
    const now = Date.now();
    const CACHE_TTL = 5 * 60 * 1000; // 5åˆ†
    let removedCount = 0;

    for (const [key, result] of this.performanceCache.entries()) {
      if (now - result.timestamp > CACHE_TTL) {
        this.performanceCache.delete(key);
        removedCount++;
      }
    }    if (removedCount > 0) {
      debug.log(`ğŸš€ ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—: ${removedCount}ä»¶å‰Šé™¤`);
      debug.typing.log();
    }
  }

  /**
   * ğŸš€ Phase 1: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆå–å¾—
   */
  getPerformanceStats() {
    const totalRequests = this.cacheHitCount + this.cacheMissCount;
    const cacheHitRate = totalRequests > 0 ? (this.cacheHitCount / totalRequests) * 100 : 0;
    
    const avgProcessingTime = this.performanceMetrics.keyProcessingTimes.length > 0 
      ? this.performanceMetrics.keyProcessingTimes.reduce((a, b) => a + b, 0) / this.performanceMetrics.keyProcessingTimes.length
      : 0;

    return {
      cacheSize: this.performanceCache.size,
      cacheHitRate: Math.round(cacheHitRate * 100) / 100,
      cacheHits: this.cacheHitCount,
      cacheMisses: this.cacheMissCount,
      averageProcessingTime: Math.round(avgProcessingTime * 100) / 100,
      idleComputations: this.performanceMetrics.idleComputations,
      domUpdatesSkipped: this.performanceMetrics.domUpdatesSkipped,
      performance: {
        estimatedSpeedup: cacheHitRate > 0 ? `${(100 / (100 - cacheHitRate)).toFixed(1)}x` : '1.0x',
        phase1Status: 'ACTIVE'
      }
    };
  }

  /**
   * ğŸš€ Phase 1: çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ
   */
  resetPerformanceStats(): void {
    this.cacheHitCount = 0;
    this.cacheMissCount = 0;
    this.performanceMetrics.keyProcessingTimes = [];
    this.performanceMetrics.idleComputations = 0;
    this.performanceMetrics.domUpdatesSkipped = 0;    this.performanceCache.clear();
    
    debug.log('ğŸš€ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹çµ±è¨ˆãƒªã‚»ãƒƒãƒˆ');
    debug.typing.log();
  }

  /**
   * ãƒªã‚»ãƒƒãƒˆ
   */
  reset(): void {
    this.state.currentIndex = 0;
    this.state.keyCount = 0;
    this.state.mistakeCount = 0;
    this.state.startTime = 0;

    this.state.typingChars.forEach(char => char.reset());
    this.updateDisplay();
  }

  /**
   * ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  cleanup(): void {
    if (this.keyHandler) {
      document.removeEventListener('keydown', this.keyHandler, { capture: true } as any);
      this.keyHandler = undefined;
    }
    
    this.container = null;
    this.displayElements = null;
    this.onProgress = undefined;
    this.onComplete = undefined;
    this.performanceCache.clear();    this.predictionQueue = [];
    this.idleScheduled = false;
    
    debug.log('ğŸš€ HyperTypingEngine ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†');
    debug.typing.log();
  }
  /**
   * ğŸš€ Phase 2: WebAssemblyçµ±åˆåˆæœŸåŒ–
   */
  private async initializeWasmIntegration(): Promise<void> {
    try {
      debug.log('ğŸš€ Phase 2: WebAssemblyçµ±åˆåˆæœŸåŒ–é–‹å§‹...');
      
      // WebAssemblyãƒ—ãƒ­ã‚»ãƒƒã‚µã®åˆæœŸåŒ–ã‚’å¾…æ©Ÿ
      await wasmTypingProcessor.waitForInitialization();
      
      const status = wasmTypingProcessor.getStatus();
      debug.log(`âœ… Phase 2: ${status.mode} åˆæœŸåŒ–å®Œäº†`);
      
      // æ€§èƒ½è¨ˆæ¸¬ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã«WASMçŠ¶æ…‹ã‚’è¨˜éŒ²
      this.performanceMetrics.wasmHitRate = status.isWasmAvailable ? 1 : 0;
      
    } catch (error) {
      debug.warn('âš ï¸ Phase 2: WebAssemblyçµ±åˆã‚¨ãƒ©ãƒ¼ - TypeScriptãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç¶™ç¶š', error);
    }
  }
  /**
   * ğŸš€ Phase 2: WebAssemblyé«˜é€Ÿæ–‡å­—ãƒãƒƒãƒãƒ³ã‚°å‡¦ç†
   */
  private async processKeyWithWasm(key: string): Promise<boolean> {
    const startTime = performance.now();
    
    try {
      const currentChar = this.state.typingChars[this.state.currentIndex];
      if (!currentChar) return false;

      // WebAssemblyã§é«˜é€Ÿæ–‡å­—ãƒãƒƒãƒãƒ³ã‚°åˆ¤å®š
      const isMatch = await wasmTypingProcessor.matchCharacter(
        key, 
        currentChar.patterns
      );

      // Phase 2 æ€§èƒ½è¨ˆæ¸¬
      const processingTime = performance.now() - startTime;
      this.performanceMetrics.wasmProcessingTimes.push(processingTime);

      return isMatch;
    } catch (error) {
      debug.warn('WASMæ–‡å­—ãƒãƒƒãƒãƒ³ã‚°ã‚¨ãƒ©ãƒ¼ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®TypeScriptå‡¦ç†
      return this.fallbackMatchCharacter(key);
    }
  }

  /**
   * TypeScriptãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ–‡å­—ãƒãƒƒãƒãƒ³ã‚°
   */
  private fallbackMatchCharacter(key: string): boolean {
    const currentChar = this.state.typingChars[this.state.currentIndex];
    if (!currentChar) return false;
    
    return currentChar.patterns.some((alt: string) => alt.startsWith(key));
  }

  /**
   * ğŸš€ Phase 2: WebAssemblyæ€§èƒ½ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
   */
  getWasmPerformanceReport(): any {
    const status = wasmTypingProcessor.getStatus();
    const wasmAvgTime = this.performanceMetrics.wasmProcessingTimes.length > 0
      ? this.performanceMetrics.wasmProcessingTimes.reduce((a, b) => a + b, 0) / this.performanceMetrics.wasmProcessingTimes.length
      : 0;

    const tsAvgTime = this.performanceMetrics.keyProcessingTimes.length > 0
      ? this.performanceMetrics.keyProcessingTimes.reduce((a, b) => a + b, 0) / this.performanceMetrics.keyProcessingTimes.length
      : 0;

    const speedupRatio = tsAvgTime > 0 && wasmAvgTime > 0 ? tsAvgTime / wasmAvgTime : 1;

    return {
      phase2Status: status,
      performance: {
        wasmAvgProcessingTime: `${wasmAvgTime.toFixed(4)}ms`,
        typescriptAvgProcessingTime: `${tsAvgTime.toFixed(4)}ms`,
        speedupRatio: `${speedupRatio.toFixed(1)}x`,
        wasmProcessingCount: this.performanceMetrics.wasmProcessingTimes.length,
        totalKeyProcessingCount: this.performanceMetrics.keyProcessingTimes.length,
        wasmUtilizationRate: `${(this.performanceMetrics.wasmHitRate * 100).toFixed(1)}%`
      },
      summary: status.isWasmAvailable 
        ? `ğŸš€ WebAssemblyé«˜é€ŸåŒ–æœ‰åŠ¹ - ${speedupRatio.toFixed(1)}å€é«˜é€Ÿ`
        : 'âš ï¸ TypeScriptãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å®Ÿè¡Œä¸­'
    };
  }

  /**
   * ğŸš€ Phase 2: WebAssemblyé«˜é€Ÿãƒãƒƒãƒå¤‰æ›å‡¦ç†
   */
  private async processWithWasmBatch(textArray: string[]): Promise<TypingChar[][]> {
    const startTime = performance.now();
    
    try {
      // WebAssemblyã§é«˜é€Ÿãƒãƒƒãƒå‡¦ç†
      const results = await wasmTypingProcessor.batchConvert(textArray);
      
      // Phase 2 æ€§èƒ½è¨ˆæ¸¬
      const processingTime = performance.now() - startTime;
      this.performanceMetrics.wasmProcessingTimes.push(processingTime);
      this.performanceMetrics.wasmHitRate = Math.min(this.performanceMetrics.wasmHitRate + 0.1, 1);
      
      debug.log(`ğŸš€ WebAssemblyãƒãƒƒãƒå‡¦ç†å®Œäº†: ${textArray.length}ä»¶ ${processingTime.toFixed(3)}ms`);
      return results;
      
    } catch (error) {
      debug.warn('WASMãƒãƒƒãƒå‡¦ç†ã‚¨ãƒ©ãƒ¼ - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ä½¿ç”¨:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: æ—¢å­˜ã®TypeScriptå‡¦ç†
      return textArray.map(text => this.fallbackConvertText(text));
    }
  }

  /**
   * ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ãƒ†ã‚­ã‚¹ãƒˆå¤‰æ›
   */
  private fallbackConvertText(text: string): TypingChar[] {
    // æ—¢å­˜ã®JapaneseConverterç›¸å½“ã®å‡¦ç†
    return text.split('').map(char => {
      switch (char) {
        case 'ã‚': return new TypingChar('ã‚', ['a']);
        case 'ã‹': return new TypingChar('ã‹', ['ka', 'ca']);
        case 'ã—': return new TypingChar('ã—', ['si', 'shi', 'ci']);
        case 'ã‚“': return new TypingChar('ã‚“', ['nn', 'xn', 'n']);
        case 'ã“': return new TypingChar('ã“', ['ko', 'co']);
        case 'ã«': return new TypingChar('ã«', ['ni']);
        case 'ã¡': return new TypingChar('ã¡', ['ti', 'chi']);
        case 'ã¯': return new TypingChar('ã¯', ['ha']);
        default: return new TypingChar(char, [char]);
      }
    });
  }
}